<!DOCTYPE html>
<html>

<head>
<title>Physijs</title>
        <meta charset=utf-8>
        <style>
            body { margin: 0; }
            canvas { width: 100%; height: 100% }
        </style>

    <script type="text/javascript" src="../js/three.js"></script>
    <script type="text/javascript" src="../js/physi.js"></script>
    <script type="text/javascript" src="../js/OrbitControls.js"></script>

    <script type="text/javascript" src="./ObjetoMovible.js"></script>
    <script type="text/javascript" src="./Asteroide.js"></script>
    <script type="text/javascript" src="./Nave.js"></script>
    <script type="text/javascript" src="./Bala.js"></script>
    <script type="text/javascript" src="./Cancha.js"></script>


</head>

<body>
    <div id="viewport"></div>

<script type="text/javascript">

    'use strict';

    Physijs.scripts.worker = '../js/physijs_worker.js';
    Physijs.scripts.ammo = '../js/ammo.js';

    var initScene, render, renderer, scene, camera, box;
    var naveMaterial = new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true});
    var nave = new Nave();
    var box = new Asteroide();
    var cancha = new Cancha();

    function wrapAround (mesh) {
        //console.log(mesh.position.y);
        if(mesh.name != "camara" && !revisarObjetoCamara(mesh)){
            if(mesh.position.y > window.innerHeight / 2){ // limite inferior de la pantalla
                                console.log(mesh.position.y + " " + window.innerHeight / 2);

                mesh.position.y = - window.innerHeight / 2;
            }
            else if(mesh.position.y < - window.innerHeight / 2){ // limite superior de la pantalla
                mesh.position.y =  window.innerHeight / 2;
            }
            else if(mesh.position.x > window.innerWidth / 2){ // limite derecho
                mesh.position.x = - window.innerWidth / 2;
            }
            else if(mesh.position.x < 0){ // limite izquierdo
                mesh.position.x = window.innerWidth / 2;
            }
        }
    }

    function revisarObjetoCamara(mesh) {
        
        var frustum = new THREE.Frustum();
        var cameraViewProjectionMatrix = new THREE.Matrix4();

        // every time the camera or objects change position (or every frame)

        camera.updateMatrixWorld(); // make sure the camera matrix is updated
        camera.matrixWorldInverse.getInverse( camera.matrixWorld );
        cameraViewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
        frustum.setFromMatrix( cameraViewProjectionMatrix );

        // frustum is now ready to check all the objects you need

        return frustum.intersectsObject( mesh );
    }

    function createRender(){

        //ponemos color de fondo y el tamaÃ±o de la ventana
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xEEEEEE, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;
        return renderer;
    }

    initScene = function() {
        renderer = createRender();
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );

        scene = new Physijs.Scene;
        scene.setGravity(new THREE.Vector3(0,0,0));  
        scene.addEventListener('update', function() {
            scene.simulate();
        });

        /*camera = new THREE.PerspectiveCamera(
            35,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );
        camera.position.set( 0, 0, 200 );
        */
        camera = new THREE.OrthographicCamera(
            window.innerWidth / - 2, 
            window.innerWidth / 2, 
            window.innerHeight / 2, 
            window.innerHeight / - 2, 
            - 500, 
            1000
        );

        camera.name = "camara";
        camera.lookAt( scene.position );
        scene.add( camera );
        
        box.position.y = 120;

        nave.name = "nave";
        box.name = "asteroide";
        nave.addEventListener( 'collision', function( other_object, linear_velocity, angular_velocity ) {

            other_object.material.color.setHex( 0xff0000 );
        });
        box.addEventListener( 'collision', function( other_object, linear_velocity, angular_velocity ) {

            other_object.material.color.setHex( 0x0000ff );
        });
        
        document.addEventListener('keydown', function(event) {
            if(event.keyCode == 37) { //izquierda
                nave.rotation.z += 0.11;
            }
            else if(event.keyCode == 39) { //derecha
                nave.rotation.z -= 0.11;
                //console.log(nave.rotation.z);
            }
            else if(event.keyCode == 38) { //arriba
                nave.position.x -= 3*Math.sin(nave.rotation.z);
                nave.position.y += 3*Math.cos(nave.rotation.z);
            }
            else if(event.keyCode == 32) { //espacio
                nave.disparar(scene);
                revisarObjetoCamara(nave);
            }
        });
        console.log(window.innerHeight + " " + window.innerWidth);
        scene.add(nave);
        scene.add(box);
        //var controls = new THREE.OrbitControls( camera );
        requestAnimationFrame( render );
    };
    /*
    for (var i = scene.children.length - 1; i >= 0; i--) {
            wrapAround(scene.children[i]);
        }
    */

    render = function() {
        scene.simulate(); // run physics
        renderer.render( scene, camera); // render the scene
        wrapAround( box );
        nave.__dirtyPosition = true;
        nave.__dirtyRotation = true;
        requestAnimationFrame( render );
    };

    window.onload = initScene();

    </script>
</body>
</html>